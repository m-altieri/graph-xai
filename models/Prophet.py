# -*- coding: utf-8 -*-
"""Prophet.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15VSreZ6SbNhHP7amf_T1ab0lTEmTpf-2
"""

import prophet
import pandas as pd
import numpy as np
import logging
from datetime import datetime

class Prophet:
  """
  Prophet model implementation, using the official prophet library (https://facebook.github.io/prophet/).
  This class complies to the interface used for the other models, with fit, predict and compile, and also set_node like for GCNLSTM.
  The model is initialized when the object is instantiated, and is never reset.
  """
  def __init__(self, node=0, multivariate=False):
    self.logger = logging.getLogger(__name__)
    self.logger.info('{} initializing with node {}, multivariate={}'.format(__name__, node, multivariate))

    self.node = node
    self.compiled = False
    self.multivariate = multivariate
    self.model = None
    self.fitted_on_x = []
    self.fitted_on_y = []
    self.date = datetime.today().strftime('%Y-%m-%d')

    self.logger.info(__name__ + ' initialized.')

  def set_node(self, node):
    """
    Set the node to train and predict for.
    If never called, the default node will be 0.
    This model can only be trained for one node at a time.

    Parameters
    ----------
    node : int
        Node to set for training and prediction. Doesn't check for node validity.
    """
    self.node = node

  def fit(self, x, y, **kwargs):
    """
    Incrementally fits the model on the new given labels.

    Every call to fit() trains the model incrementally (i.e. the model is retrained on all previously seen instances every time fit() is called);
    in this way, it's natively compatible with the tf incremental training workflow used for the landmark evaluation.

    Parameters
    ----------
    x : any
        Unused.
    y : array
        Matrix of shape [Seqs, Steps, Nodes].
    """
    if not self.multivariate:
      x = x[:,:,:,:1]

    B, T, N, F = np.shape(x)

    self.model = prophet.Prophet()
    for f in range(F): self.model.add_regressor(str(f))
    
    if len(self.fitted_on_x) != len(self.fitted_on_y): # Controllo
      self.logger.error('Different lengths for x and y.')
      assert len(self.fitted_on_x) == len(self.fitted_on_y)

    if len(self.fitted_on_x) != 0:
      self.fitted_on_x = np.concatenate((self.fitted_on_x, x), axis=0)
      self.fitted_on_y = np.concatenate((self.fitted_on_y, y), axis=0)
    else:
      self.fitted_on_x = x
      self.fitted_on_y = y

    ts_x = np.stack([np.ravel(self.fitted_on_x[:,:,self.node,f]) for f in range(F)], axis=1) # [B*T,F]
    ts_y = np.ravel(self.fitted_on_y[:,:,self.node]) # [B*T,]
    df = pd.DataFrame(ts_x, columns = [str(f) for f in range(F)])
    df.insert(loc=0, column='ds', value=pd.date_range(start=self.date, periods=len(df), freq='D'))
    df.insert(loc=F+1, column='y', value=ts_y)

    self.model.fit(df)

  def predict(self, x, **kwargs):
    """
    Predict the target value for the next prediction steps.

    Parameters
    ----------
    x : tensor of shape [1, Prediction Steps, Nodes, Features]
    """
    B, P, N, F = np.shape(x)
    assert B == 1

    future = self.model.make_future_dataframe(periods=P, include_history=False)
    df = pd.DataFrame(x[0,:,self.node,:], columns = [str(f) for f in range(F)])
    df.insert(loc=0, column='ds', value=future['ds'])

    preds_df = self.model.predict(df)
    return np.array(preds_df['yhat'])

  def compile(self, **kwargs):
    """
    Does nothing. It's added for compatibility reasons.
    """
    self.compiled = True
